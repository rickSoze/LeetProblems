package JZOffer;

public class JZ56_数组中数字出现的次数 {
	/*
	一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。
	请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

	示例 1：
	输入：nums = [4,1,4,6]
	输出：[1,6] 或 [6,1]
	示例 2：

	输入：nums = [1,2,10,4,1,4,3,3]
	输出：[2,10] 或 [10,2]
	*/
	class Solution {
//时间复杂度On可以用map，但是空间复杂度O1无法满足；因此考虑别的方法。
//排序时间复杂度太高，
//思路1：第一次遍历，异或每一个数，得到那两个数的异或值x。 第二次遍历，只要有两个数的异或值等于x，返回这两个数。
//但是这样会有一个问题，就是可能有很多个组合都能异或出同一个结果x，怎么解决呢？
//不会

		//最优解：
/*
* 第一轮整体遍历，求出a^b（因为相同的数字异或为0，0异或任何数字为数字自身）
然后结合a^b以及原来数组求出这两个数字
原理：用一个只有一位为1的数字来遍历异或整个数组，把这个数组分成两个子数组（异或结果相同的数字在同一个子数组），
* 如果是两个相同的数字，它们一定在同一个子数组里（保证子数组异或时为0），
* 现在只需要把两个只出现一次的数字分到不同的子数组，那么子数组分别遍历异或得到的两个数字就是这两个数字。
怎么把两个只出现一次的数字分到不同地子数组？
找到a^b第一个为1的位置，异或结果为1说明a和b在这一位上不同，
* 那用只有这一位为1的数字m去分别异或a和b，得到的结果一定不同，
* 也就把a和b分到了不同的子数组。结合上一点得出结果。
* */
		public int[] singleNumbers(int[] nums) {
			int x=0,y=0,n=0,m=1;
			for (int num : nums) {
				n^=num;
			}
			//这里一定是==0 而不是	!=1
			while ((n&m)==0) m<<=1;

			for (int num : nums) {
				if ((num&m)!=0){   //这里用!=0 不要用==1 因为可能有其他结果。
				    x^=num;
				}else {
					y^=num;
				}
			}
			return new int[]{x,y};
		}
	}
}
class Solution {
	public int[] singleNumbers(int[] nums) {
		int x = 0, y = 0, n = 0, m = 1;
		for(int num : nums)               // 1. 遍历异或
			n ^= num;
		while((n & m) == 0)               // 2. 循环左移，计算 m
			m <<= 1;
		for(int num: nums) {              // 3. 遍历 nums 分组
			if((num & m) != 0) x ^= num;  // 4. 当 num & m != 0
			else y ^= num;                // 4. 当 num & m == 0
		}
		return new int[] {x, y};          // 5. 返回出现一次的数字
	}
}


